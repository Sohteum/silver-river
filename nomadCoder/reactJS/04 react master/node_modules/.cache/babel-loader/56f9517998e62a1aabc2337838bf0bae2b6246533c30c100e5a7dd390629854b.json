{"ast":null,"code":"var _jsxFileName = \"D:\\\\YongSohtEum\\\\pwa_class\\\\05react\\\\react-app\\\\src\\\\App.js\",\n  _s = $RefreshSig$();\nimport { useState } from \"react\";\nimport { useEffect } from \"react\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nfunction fnGetDDay(dday, now) {\n  // let dDayTimeStamp = dday\n  // let timeStamp = now\n  let diff = dday - now; //남은 시간을 밀리세컨드로 환산(1000분의 1초)\n  let remainfSec = parseInt(diff / 1000); //남은시간을  초로 환산\n  let date = Math.floor(remainfSec / (24 * 60 * 60)); //몇일 남았는지 환산\n  remainfSec = remainfSec % (24 * 60 * 60); //남은 시간(일차 빼고) 일로 나누고 남은 나머지 초\n  let hour = Math.floor(remainfSec / (60 * 60)); //몇시간 남았는지\n  remainfSec = remainfSec % (60 * 60); //시간으로 나누고 남은 나머지 초\n  let min = Math.floor(remainfSec / 60); //몇분 남았는지\n  let sec = remainfSec % 60; //분으로 나누고 몇초 남았는지\n  console.log(date, hour, min, sec);\n  // _setDate(date)\n  // _setHour(hour)\n  // _setMin(min)\n  // _setSec(sec) //이건 안에서만 가능\n  //60분이 1시간이니까 3600초, 소수점이 나오니까 floor로 소수점을 내려버림\n\n  return {\n    date,\n    hour,\n    min,\n    sec\n  };\n}\nfunction App() {\n  _s();\n  // const day = new Date()\n  // day.getTime()\n  let timeStamp = Date.now(); //1000곱한 시간이 지금까지 흐른 초, 실시간으로 구해야함(업데이트되어야함, 그래서 셋인터벌)\n  //내가 만약 미래 특정시간(바뀌지 않는 시간)을 구하고 싶으면 미래시간 - 지금시간을 빼면 됨.\n  const dDayTimeStamp = new Date(2023, 3, 26).getTime(); //이렇게 만들면 현재 날짜 아니면 안에 날짜를 넣어줘야 디데이가 됨\n  const [_date, _setDate] = useState();\n  const [_hour, _setHour] = useState();\n  const [_min, _setMin] = useState();\n  const [_sec, _setSec] = useState();\n  const dDay = fnGetDDay(dDayTimeStamp, timeStamp);\n  function fnSetDDay() {\n    const {\n      date,\n      hour,\n      min,\n      sec\n    } = fnGetDDay(dDayTimeStamp, timeStamp);\n    _setDate(date); //화면을 바꾸겠다는건 다시 실행하겠다는거니까 계속 걸림 그래서 무한루프에 빠짐.\n    _setHour(hour);\n    _setMin(min);\n    _setSec(sec);\n  }\n  useEffect(() => {\n    fnSetDDay();\n    let intervalID = setInterval(() => {\n      timeStamp = Date.now();\n      fnSetDDay();\n    }, 1000); //항상 습관적으로 클리어 할것\n    return () => {\n      clearInterval(intervalID);\n    };\n  }, []);\n  // console.log(timeStamp);\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(\"h1\", {\n      children: \"dDay\"\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 65,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(\"p\", {\n      children: [_date, \"\\uC77C:\", _hour, \"\\uC2DC\\uAC04:\", _min, \"\\uBD84:\", _sec, \"\\uCD08\"]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 66,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n}\n_s(App, \"2Ybjt0WN0lsCb/PFcoj2fYpNGSs=\");\n_c = App;\nexport default App;\nvar _c;\n$RefreshReg$(_c, \"App\");","map":{"version":3,"names":["useState","useEffect","jsxDEV","_jsxDEV","Fragment","_Fragment","fnGetDDay","dday","now","diff","remainfSec","parseInt","date","Math","floor","hour","min","sec","console","log","App","_s","timeStamp","Date","dDayTimeStamp","getTime","_date","_setDate","_hour","_setHour","_min","_setMin","_sec","_setSec","dDay","fnSetDDay","intervalID","setInterval","clearInterval","children","fileName","_jsxFileName","lineNumber","columnNumber","_c","$RefreshReg$"],"sources":["D:/YongSohtEum/pwa_class/05react/react-app/src/App.js"],"sourcesContent":["import { useState } from \"react\";\r\nimport { useEffect } from \"react\";\r\n\r\nfunction fnGetDDay(dday, now) {\r\n  // let dDayTimeStamp = dday\r\n  // let timeStamp = now\r\n  let diff = dday - now//남은 시간을 밀리세컨드로 환산(1000분의 1초)\r\n  let remainfSec = parseInt(diff / 1000) //남은시간을  초로 환산\r\n  let date = Math.floor(remainfSec / (24 * 60 * 60)) //몇일 남았는지 환산\r\n  remainfSec = remainfSec % (24 * 60 * 60) //남은 시간(일차 빼고) 일로 나누고 남은 나머지 초\r\n  let hour = Math.floor(remainfSec / (60 * 60)) //몇시간 남았는지\r\n  remainfSec = remainfSec % (60 * 60) //시간으로 나누고 남은 나머지 초\r\n  let min = Math.floor(remainfSec / 60) //몇분 남았는지\r\n  let sec = remainfSec % 60 //분으로 나누고 몇초 남았는지\r\n  console.log(date, hour, min, sec);\r\n  // _setDate(date)\r\n  // _setHour(hour)\r\n  // _setMin(min)\r\n  // _setSec(sec) //이건 안에서만 가능\r\n  //60분이 1시간이니까 3600초, 소수점이 나오니까 floor로 소수점을 내려버림\r\n\r\n  return {\r\n    date,\r\n    hour,\r\n    min,\r\n    sec,\r\n  }\r\n}\r\nfunction App() {\r\n\r\n  // const day = new Date()\r\n  // day.getTime()\r\n  let timeStamp = Date.now()//1000곱한 시간이 지금까지 흐른 초, 실시간으로 구해야함(업데이트되어야함, 그래서 셋인터벌)\r\n  //내가 만약 미래 특정시간(바뀌지 않는 시간)을 구하고 싶으면 미래시간 - 지금시간을 빼면 됨.\r\n  const dDayTimeStamp = new Date(2023, 3, 26).getTime() //이렇게 만들면 현재 날짜 아니면 안에 날짜를 넣어줘야 디데이가 됨\r\n  const [_date, _setDate] = useState()\r\n  const [_hour, _setHour] = useState()\r\n  const [_min, _setMin] = useState()\r\n  const [_sec, _setSec] = useState()\r\n\r\n  const dDay = fnGetDDay(dDayTimeStamp, timeStamp)\r\n\r\n\r\n  function fnSetDDay() {\r\n    const {date, hour, min, sec} = fnGetDDay(dDayTimeStamp, timeStamp)\r\n    _setDate(date) //화면을 바꾸겠다는건 다시 실행하겠다는거니까 계속 걸림 그래서 무한루프에 빠짐.\r\n    _setHour(hour)\r\n    _setMin(min)\r\n    _setSec(sec)\r\n  }\r\n\r\n  useEffect(() => {\r\n    fnSetDDay()\r\n    let intervalID = setInterval(() => {\r\n      timeStamp = Date.now()\r\n      fnSetDDay()\r\n    }, 1000)//항상 습관적으로 클리어 할것\r\n    return (() => {\r\n      clearInterval(intervalID)\r\n    })\r\n  }, [])\r\n  // console.log(timeStamp);\r\n  return (\r\n    <>\r\n      <h1>dDay</h1>\r\n      <p>{_date}일:{_hour}시간:{_min}분:{_sec}초</p>\r\n    </>\r\n  );\r\n}\r\n\r\nexport default App;\r\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}